//go:build ignore

package main

import (
	"embed"
	"fmt"
	"math"
	"os"
	"strings"
	"text/template"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/lmittmann/solc/internal/console"
)

//go:embed *.tmpl
var templates embed.FS

func main() {
	if err := run(); err != nil {
		fmt.Printf("error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// parse templates
	tmpl, err := template.New("").
		Funcs(template.FuncMap{
			"toUpper":   strings.ToUpper,
			"typeToArg": typeToArg,
		}).
		ParseFS(templates, "*")
	if err != nil {
		return err
	}

	signatures := genSignatures()

	args := make([]Args, len(signatures))
	for i, sig := range signatures {
		h := crypto.Keccak256([]byte("log(" + strings.Join(sig, ",") + ")"))
		var sel [4]byte
		copy(sel[:], h)

		args[i] = Args{
			Sel:  sel,
			Args: sig,
		}
	}

	model := &model{
		Addr: console.Addr,
		Args: args,
	}

	if err := gen("args.go", tmpl, model); err != nil {
		return err
	}
	if err := gen("console.sol", tmpl, model); err != nil {
		return err
	}
	return nil
}

func gen(name string, tmpl *template.Template, model *model) error {
	f, err := os.Create(name)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "// Code generated by go generate; DO NOT EDIT.")

	return tmpl.ExecuteTemplate(f, name+".tmpl", model)
}

type model struct {
	Addr common.Address
	Args []Args
}

type Args struct {
	Sel  [4]byte // 4 bytes selector
	Args []string
}

func typeToArg(t string) string {
	switch t {
	case "string", "bytes":
		return t + " memory"
	default:
		return t
	}
}

func genSignatures() [][]string {
	s := []string{"string", "uint", "int", "address", "bool"}

	signatures := permutations(s, 1)

	perms2 := permutations(s, 2)
	signatures = append(signatures, perms2...)

	perms3 := permutations(s, 3)
	signatures = append(signatures, perms3...)

	for _, perms := range [][][]string{perms2, perms3} {
		for _, perm := range perms {
			p := make([]string, len(perm)*2)
			for i, typ := range perm {
				p[i*2] = "string"
				p[i*2+1] = typ
			}
			signatures = append(signatures, p)
		}
	}

	return signatures
}

// permutations returns all permutations of the elements in the given slice for
// the given size.
func permutations(s []string, size int) [][]string {
	var perms [][]string

	for i := 0; i < int(math.Pow(float64(len(s)), float64(size))); i++ {
		perm := make([]string, size)

		n := i
		for j := range perm {
			perm[j] = s[n%len(s)]
			n /= len(s)
		}
		perms = append(perms, perm)
	}
	return perms
}
